import 'package:supabase_flutter/supabase_flutter.dart';
import '../config/supabase_config.dart';
import '../models/payment_model.dart';
import '../models/receipt_model.dart';

import 'upi_intent_service.dart' as upi;
import 'supabase_wallet_service.dart';
import 'supabase_receipt_service.dart';
import 'supabase_user_service.dart';
import 'notification_service.dart';
import 'supabase_settings_service.dart';

/// Service for handling payment processing and management using Supabase
class SupabasePaymentService {
  final SupabaseClient _supabase = SupabaseConfig.client;
  final SupabaseClient _adminSupabase = SupabaseConfig.adminClient;
  final upi.UPIIntentService _upiService = upi.UPIIntentService();
  final SupabaseWalletService _walletService = SupabaseWalletService();
  final SupabaseReceiptService _receiptService = SupabaseReceiptService();

  final SupabaseUserService _userService = SupabaseUserService();
  final NotificationService _notificationService = NotificationService();
  final SupabaseSettingsService _settingsService = SupabaseSettingsService();

  /// Create a new payment record
  Future<PaymentResult> createPayment({
    required String userId,
    required double amount,
    required PaymentMethod method,
    double extraCharges = 0.0,
    String? note,
  }) async {
    try {
      // First, get the user's Supabase ID from the users table
      final userResponse = await _adminSupabase
          .from('users')
          .select('id')
          .eq('firebase_uid', userId)
          .single();

      final userSupabaseId = userResponse['id'] as String;

      // Generate a temporary transaction ID for UPI payments to satisfy the constraint
      String? tempTransactionId;
      if (method == PaymentMethod.UPI || method == PaymentMethod.COMBINED) {
        // Generate shorter, Paytm-compatible transaction ID (max 20 chars)
        final timestamp = DateTime.now().millisecondsSinceEpoch.toString();
        final shortTimestamp = timestamp.substring(timestamp.length - 8); // Last 8 digits
        tempTransactionId = 'TEMP$shortTimestamp';
      }

      final payment = PaymentModel(
        id: '', // Will be generated by Supabase
        userId: userSupabaseId, // Use Supabase user ID, not Firebase UID
        amount: amount,
        extraCharges: extraCharges,
        method: method,
        status: PaymentStatus.INCOMPLETE, // Start as incomplete until payment is actually made
        createdAt: DateTime.now(),
        receiptNumber: _generateReceiptNumber(),
        year: DateTime.now().year,
        userFirebaseUid: userId, // Store Firebase UID separately
        transactionId: tempTransactionId, // Temporary transaction ID for UPI payments
      );

      // Use admin client to bypass RLS
      final response = await _adminSupabase
          .from('payments')
          .insert(payment.toSupabase())
          .select()
          .single();

      final createdPayment = PaymentModel.fromSupabase(response);

      return PaymentResult(
        success: true,
        paymentId: createdPayment.id,
        payment: createdPayment,
        message: 'Payment created successfully',
      );
    } catch (e) {
      return PaymentResult(
        success: false,
        error: 'Failed to create payment: $e',
      );
    }
  }

  /// Process UPI payment
  Future<UPIPaymentResult> processUPIPayment({
    required String userId,
    required double amount,
    double extraCharges = 0.0,
    String? note,
  }) async {
    try {
      // Create payment record
      final paymentResult = await createPayment(
        userId: userId,
        amount: amount + extraCharges,
        method: PaymentMethod.UPI,
        extraCharges: extraCharges,
        note: note,
      );

      if (!paymentResult.success || paymentResult.paymentId == null) {
        return UPIPaymentResult(
          success: false,
          error: paymentResult.error ?? 'Failed to create payment',
        );
      }

      // Launch UPI intent
      final upiResult = await _upiService.launchUPIForPayment(
        amount: amount + extraCharges,
        userId: userId,
        paymentId: paymentResult.paymentId!,
        note: note,
      );

      // If UPI was launched successfully, mark payment as complete
      if (upiResult.success) {
        await markPaymentAsComplete(
          paymentId: paymentResult.paymentId!,
          transactionId: upiResult.transactionId,
        );
      }

      return UPIPaymentResult(
        success: upiResult.success,
        paymentId: paymentResult.paymentId,
        upiResult: upiResult,
        error: upiResult.error,
      );
    } catch (e) {
      return UPIPaymentResult(
        success: false,
        error: 'UPI payment processing failed: $e',
      );
    }
  }

  /// Update payment with real UPI transaction ID
  Future<bool> updateUPITransactionId({
    required String paymentId,
    required String transactionId,
  }) async {
    try {
      await _adminSupabase
          .from('payments')
          .update({
            'transaction_id': transactionId,
            'updated_at': DateTime.now().toIso8601String(),
          })
          .eq('id', paymentId);

      return true;
    } catch (e) {
      return false;
    }
  }

  /// Mark payment as complete (change from INCOMPLETE to PENDING for admin approval)
  Future<bool> markPaymentAsComplete({
    required String paymentId,
    String? transactionId,
    String? screenshotUrl,
  }) async {
    try {
      final updateData = <String, dynamic>{
        'status': PaymentStatus.PENDING.name,
        'updated_at': DateTime.now().toIso8601String(),
        'paid_at': DateTime.now().toIso8601String(),
      };

      if (transactionId != null) {
        updateData['transaction_id'] = transactionId;
      }

      if (screenshotUrl != null) {
        updateData['screenshot_url'] = screenshotUrl;
      }

      await _adminSupabase
          .from('payments')
          .update(updateData)
          .eq('id', paymentId);

      return true;
    } catch (e) {
      return false;
    }
  }

  /// Process wallet payment
  Future<WalletPaymentResult> processWalletPayment({
    required String userId,
    required double amount,
    double extraCharges = 0.0,
    String? note,
  }) async {
    try {
      final totalAmount = amount + extraCharges;

      // Check wallet balance
      final walletBalance = await _walletService.getWalletBalance(userId);
      if (walletBalance < totalAmount) {
        return WalletPaymentResult(
          success: false,
          currentBalance: walletBalance,
          requiredAmount: totalAmount,
          error: 'Insufficient wallet balance',
        );
      }

      // Create payment record
      final paymentResult = await createPayment(
        userId: userId,
        amount: totalAmount,
        method: PaymentMethod.WALLET,
        extraCharges: extraCharges,
        note: note,
      );

      if (!paymentResult.success || paymentResult.paymentId == null) {
        return WalletPaymentResult(
          success: false,
          error: paymentResult.error ?? 'Failed to create payment',
        );
      }

      // Process wallet transaction
      final walletTransactionId = await _walletService.deductMoneyFromWallet(
        firebaseUid: userId,
        amount: totalAmount,
        transactionId: paymentResult.paymentId!,
        purpose: 'PAYMENT',
        description: 'Payment for subscription - ${paymentResult.payment?.receiptNumber}',
      );

      // Auto-approve wallet payments
      await updatePaymentStatus(
        paymentId: paymentResult.paymentId!,
        newStatus: PaymentStatus.APPROVED,
        adminId: 'system',
      );

      return WalletPaymentResult(
        success: true,
        paymentId: paymentResult.paymentId!,
        transactionId: walletTransactionId,
        newBalance: await _walletService.getWalletBalance(userId),
        message: 'Payment completed successfully using wallet',
      );
    } catch (e) {
      return WalletPaymentResult(
        success: false,
        error: 'Wallet payment processing failed: $e',
      );
    }
  }

  /// Process combined payment (wallet + UPI)
  Future<CombinedPaymentResult> processCombinedPayment({
    required String userId,
    required double amount,
    double extraCharges = 0.0,
    String? note,
  }) async {
    try {
      final totalAmount = amount + extraCharges;

      // Get wallet balance
      final walletBalance = await _walletService.getWalletBalance(userId);
      if (walletBalance <= 0) {
        return CombinedPaymentResult(
          success: false,
          error: 'No wallet balance available for combined payment',
        );
      }

      final walletAmount = walletBalance < totalAmount ? walletBalance : totalAmount;
      final upiAmount = totalAmount - walletAmount;

      if (upiAmount <= 0) {
        // Wallet balance covers full amount, process as wallet payment
        final walletResult = await processWalletPayment(
          userId: userId,
          amount: amount,
          extraCharges: extraCharges,
          note: note,
        );

        return CombinedPaymentResult(
          success: walletResult.success,
          paymentId: walletResult.paymentId,
          walletAmount: walletAmount,
          upiAmount: 0,
          walletTransactionId: walletResult.transactionId,
          newWalletBalance: walletResult.newBalance,
          error: walletResult.error,
          message: walletResult.message,
        );
      }

      // Create payment record for combined payment
      final paymentResult = await createPayment(
        userId: userId,
        amount: totalAmount,
        method: PaymentMethod.COMBINED,
        extraCharges: extraCharges,
        note: note,
      );

      if (!paymentResult.success || paymentResult.paymentId == null) {
        return CombinedPaymentResult(
          success: false,
          error: paymentResult.error ?? 'Failed to create payment',
        );
      }

      // Process wallet portion
      final walletTransactionId = await _walletService.deductMoneyFromWallet(
        firebaseUid: userId,
        amount: walletAmount,
        transactionId: paymentResult.paymentId!,
        purpose: 'PAYMENT',
        description: 'Partial payment for subscription - ${paymentResult.payment?.receiptNumber}',
      );

      // Update payment with wallet amount used
      await _adminSupabase
          .from('payments')
          .update({
            'wallet_amount_used': walletAmount,
            'upi_amount_paid': upiAmount,
          })
          .eq('id', paymentResult.paymentId!);

      // Launch UPI for remaining amount
      final upiResult = await _upiService.launchUPIForPayment(
        amount: upiAmount,
        userId: userId,
        paymentId: paymentResult.paymentId!,
        note: '$note (Remaining amount after wallet)',
      );

      // If UPI was launched successfully, mark payment as complete
      if (upiResult.success) {
        await markPaymentAsComplete(
          paymentId: paymentResult.paymentId!,
          transactionId: upiResult.transactionId,
        );
      }

      return CombinedPaymentResult(
        success: true,
        paymentId: paymentResult.paymentId!,
        walletAmount: walletAmount,
        upiAmount: upiAmount,
        walletTransactionId: walletTransactionId,
        newWalletBalance: await _walletService.getWalletBalance(userId),
        upiResult: upiResult,
        message: 'Wallet amount deducted. Complete UPI payment for remaining amount.',
      );
    } catch (e) {
      return CombinedPaymentResult(
        success: false,
        error: 'Combined payment processing failed: $e',
      );
    }
  }

  /// Get payment by ID
  Future<PaymentModel?> getPayment(String paymentId) async {
    try {
      // Use admin client to bypass RLS
      final response = await _adminSupabase
          .from('payments')
          .select()
          .eq('id', paymentId)
          .single();

      return PaymentModel.fromSupabase(response);
    } catch (e) {
      return null;
    }
  }

  /// Get user payments (excluding incomplete payments)
  Stream<List<PaymentModel>> getUserPayments(String userId) {
    return _supabase
        .from('payments')
        .stream(primaryKey: ['id'])
        .eq('user_id', userId)
        .order('created_at', ascending: false)
        .map((data) => data
            .map((item) => PaymentModel.fromSupabase(item))
            .where((payment) => payment.status != PaymentStatus.INCOMPLETE) // Exclude incomplete payments
            .toList());
  }

  /// Get incomplete payments for cleanup (admin only)
  Future<List<PaymentModel>> getIncompletePayments() async {
    try {
      final response = await _adminSupabase
          .from('payments')
          .select()
          .eq('status', PaymentStatus.INCOMPLETE.name)
          .order('created_at', ascending: false);

      return response.map((item) => PaymentModel.fromSupabase(item)).toList();
    } catch (e) {
      return [];
    }
  }

  /// Clean up old incomplete payments (older than 24 hours)
  Future<int> cleanupIncompletePayments() async {
    try {
      final cutoffTime = DateTime.now().subtract(const Duration(hours: 24));
      
      final response = await _adminSupabase
          .from('payments')
          .delete()
          .eq('status', PaymentStatus.INCOMPLETE.name)
          .lt('created_at', cutoffTime.toIso8601String());

      return response.length;
    } catch (e) {
      return 0;
    }
  }

  /// Generate unique receipt number
  String _generateReceiptNumber() {
    final now = DateTime.now();
    final year = now.year.toString().substring(2);
    final month = now.month.toString().padLeft(2, '0');
    final timestamp = now.millisecondsSinceEpoch.toString().substring(8);
    return 'RCP$year$month$timestamp';
  }

  /// Update payment status (for admin approval/rejection)
  Future<PaymentUpdateResult> updatePaymentStatus({
    required String paymentId,
    required PaymentStatus newStatus,
    required String adminId,
    String? rejectionReason,
  }) async {
    try {
      final updates = <String, dynamic>{
        'status': newStatus.name,
        'updated_at': DateTime.now().toIso8601String(),
      };

      if (newStatus == PaymentStatus.APPROVED) {
        updates['approved_at'] = DateTime.now().toIso8601String();
        updates['approved_by'] = adminId;
      }

      await _supabase
          .from('payments')
          .update(updates)
          .eq('id', paymentId);

      // Get updated payment for notifications
      final payment = await getPayment(paymentId);
      if (payment != null) {
        // Send notification to user
        final user = await _userService.getUserById(payment.userId);
        if (user != null) {
          await _notificationService.notifyPaymentStatusChange(
            user: user,
            payment: payment,
            newStatus: newStatus,
            rejectionReason: rejectionReason,
          );

          // Generate receipt for approved payments
          if (newStatus == PaymentStatus.APPROVED) {
            await _receiptService.generateReceiptPDF(
              receipt: ReceiptModel(
                id: '',
                paymentId: payment.id,
                receiptNumber: payment.receiptNumber,
                pdfUrl: '',
                generatedAt: DateTime.now(),
                language: 'en',
                userId: payment.userId,
                amount: payment.amount,
                extraCharges: payment.extraCharges,
                paymentMethod: payment.method.name,
                year: payment.year,
              ),
              user: user,
              payment: payment,
            );
          }
        }
      }

      return PaymentUpdateResult(
        success: true,
        message: newStatus == PaymentStatus.APPROVED
            ? 'Payment approved successfully'
            : 'Payment status updated successfully',
      );
    } catch (e) {
      return PaymentUpdateResult(
        success: false,
        error: 'Failed to update payment status: $e',
      );
    }
  }

  /// Get payments by status - ADMIN OPERATION
  Stream<List<PaymentModel>> getPaymentsByStatus(PaymentStatus status) {
    return _adminSupabase
        .from('payments')
        .stream(primaryKey: ['id'])
        .eq('status', status.name)
        .order('created_at', ascending: false)
        .map((data) => data.map((item) => PaymentModel.fromSupabase(item)).toList());
  }

  /// Calculate yearly fee with dynamic charges and late fees using SettingsService
  Future<FeeCalculation> calculateYearlyFee({
    required String userId,
    double? customAmount,
    double extraCharges = 0.0,
    double? wireLength,
  }) async {
    try {
      // Get settings for fee calculation
      final settings = await _settingsService.getSettings();
      print('PAYMENT DEBUG: Fetched settings - yearlyFee: ${settings.yearlyFee}');
      
      final baseAmount = customAmount ?? settings.yearlyFee;
      final wireCharges = wireLength != null ? wireLength * settings.wireChargePerMeter : 0.0;
      final lateFees = 0.0; // Calculate based on business logic
      final totalAmount = baseAmount + extraCharges + wireCharges + lateFees;

      print('PAYMENT DEBUG: Calculated baseAmount: $baseAmount, totalAmount: $totalAmount');

      // Check if user has already paid for current year
      final currentYear = DateTime.now().year;
      
      // First, get the user's Supabase ID from the users table
      final userResponse = await _adminSupabase
          .from('users')
          .select('id')
          .eq('firebase_uid', userId)
          .maybeSingle();
      
      if (userResponse != null) {
        final userSupabaseId = userResponse['id'] as String;
        
        final currentYearPayments = await _supabase
            .from('payments')
            .select()
            .eq('user_id', userSupabaseId)
            .eq('year', currentYear)
            .eq('status', PaymentStatus.APPROVED.name)
            .limit(1);

        final hasCurrentYearPayment = currentYearPayments.isNotEmpty;

        return FeeCalculation(
          baseAmount: baseAmount,
          extraCharges: extraCharges,
          wireCharges: wireCharges,
          lateFees: lateFees,
          totalAmount: totalAmount,
          hasLateFees: lateFees > 0,
          hasCurrentYearPayment: hasCurrentYearPayment,
          lateFeesPercentage: lateFees > 0 ? (lateFees / baseAmount) * 100 : 0.0,
          wireLength: wireLength ?? 0.0,
          wireChargePerMeter: settings.wireChargePerMeter,
        );
      } else {
        // User not found in Supabase, assume no current year payment
        return FeeCalculation(
          baseAmount: baseAmount,
          extraCharges: extraCharges,
          wireCharges: wireCharges,
          lateFees: lateFees,
          totalAmount: totalAmount,
          hasLateFees: lateFees > 0,
          hasCurrentYearPayment: false,
          lateFeesPercentage: lateFees > 0 ? (lateFees / baseAmount) * 100 : 0.0,
          wireLength: wireLength ?? 0.0,
          wireChargePerMeter: settings.wireChargePerMeter,
        );
      }
    } catch (e) {
      print('PAYMENT DEBUG: Error in calculateYearlyFee: $e');
      return FeeCalculation(
        baseAmount: 1000.0, // Default fallback
        extraCharges: extraCharges,
        wireCharges: 0.0,
        lateFees: 0.0,
        totalAmount: 1000.0 + extraCharges,
        hasLateFees: false,
        hasCurrentYearPayment: false,
        lateFeesPercentage: 0.0,
        wireLength: wireLength ?? 0.0,
        wireChargePerMeter: 0.0,
      );
    }
  }

  /// Get payment statistics for admin dashboard
  Future<PaymentStatistics> getPaymentStatistics() async {
    try {
      final currentYear = DateTime.now().year;

      // Get all payments for current year - ADMIN OPERATION
      final allPayments = await _adminSupabase
          .from('payments')
          .select()
          .eq('year', currentYear);

      final approvedPayments = allPayments.where((p) => p['status'] == 'APPROVED').toList();
      final pendingPayments = allPayments.where((p) => p['status'] == 'PENDING').toList();
      final rejectedPayments = allPayments.where((p) => p['status'] == 'REJECTED').toList();

      // Get overdue payments (previous years) - ADMIN OPERATION
      final overduePayments = await _adminSupabase
          .from('payments')
          .select()
          .lt('year', currentYear)
          .eq('status', 'PENDING');

      // Calculate totals
      final totalRevenue = approvedPayments.fold<double>(
        0.0,
        (sum, payment) => sum + (payment['amount'] as num).toDouble() + (payment['extra_charges'] as num).toDouble(),
      );

      final pendingAmount = pendingPayments.fold<double>(
        0.0,
        (sum, payment) => sum + (payment['amount'] as num).toDouble() + (payment['extra_charges'] as num).toDouble(),
      );

      return PaymentStatistics(
        totalPayments: allPayments.length,
        approvedPayments: approvedPayments.length,
        pendingPayments: pendingPayments.length,
        rejectedPayments: rejectedPayments.length,
        overduePayments: overduePayments.length,
        approvalRate: allPayments.isEmpty
            ? 0.0
            : (approvedPayments.length / allPayments.length) * 100,
        totalRevenue: totalRevenue,
        pendingAmount: pendingAmount,
        currentYear: currentYear,
      );
    } catch (e) {
      return PaymentStatistics(
        totalPayments: 0,
        approvedPayments: 0,
        pendingPayments: 0,
        rejectedPayments: 0,
        overduePayments: 0,
        approvalRate: 0.0,
        totalRevenue: 0.0,
        pendingAmount: 0.0,
        currentYear: DateTime.now().year,
      );
    }
  }

  /// Get all payments for a specific user
  Future<List<PaymentModel>> getPaymentsByUserId(String userId) async {
    try {
      final response = await _supabase
          .from('payments')
          .select()
          .eq('user_id', userId)
          .order('created_at', ascending: false);

      return response.map((item) => PaymentModel.fromSupabase(item)).toList();
    } catch (e) {
      throw Exception('Failed to get payments for user: $e');
    }
  }
}

// All the result classes remain the same as they're used by both services

/// Payment processing result
class PaymentResult {
  final bool success;
  final String? paymentId;
  final PaymentModel? payment;
  final String? message;
  final String? error;

  PaymentResult({
    required this.success,
    this.paymentId,
    this.payment,
    this.message,
    this.error,
  });
}

/// UPI payment result
class UPIPaymentResult {
  final bool success;
  final String? paymentId;
  final upi.UPIResult? upiResult;
  final String? error;

  UPIPaymentResult({
    required this.success,
    this.paymentId,
    this.upiResult,
    this.error,
  });
}

/// Wallet payment result
class WalletPaymentResult {
  final bool success;
  final String? paymentId;
  final String? transactionId;
  final double? newBalance;
  final double? currentBalance;
  final double? requiredAmount;
  final String? message;
  final String? error;

  WalletPaymentResult({
    required this.success,
    this.paymentId,
    this.transactionId,
    this.newBalance,
    this.currentBalance,
    this.requiredAmount,
    this.message,
    this.error,
  });
}

/// Combined payment result
class CombinedPaymentResult {
  final bool success;
  final String? paymentId;
  final double? walletAmount;
  final double? upiAmount;
  final String? walletTransactionId;
  final double? newWalletBalance;
  final upi.UPIResult? upiResult;
  final String? message;
  final String? error;

  CombinedPaymentResult({
    required this.success,
    this.paymentId,
    this.walletAmount,
    this.upiAmount,
    this.walletTransactionId,
    this.newWalletBalance,
    this.upiResult,
    this.message,
    this.error,
  });
}

/// Payment update result
class PaymentUpdateResult {
  final bool success;
  final String? message;
  final String? error;

  PaymentUpdateResult({
    required this.success,
    this.message,
    this.error,
  });
}

/// Fee calculation result
class FeeCalculation {
  final double baseAmount;
  final double extraCharges;
  final double wireCharges;
  final double lateFees;
  final double totalAmount;
  final bool hasLateFees;
  final bool hasCurrentYearPayment;
  final double lateFeesPercentage;
  final double wireLength;
  final double wireChargePerMeter;

  FeeCalculation({
    required this.baseAmount,
    required this.extraCharges,
    required this.wireCharges,
    required this.lateFees,
    required this.totalAmount,
    required this.hasLateFees,
    required this.hasCurrentYearPayment,
    required this.lateFeesPercentage,
    required this.wireLength,
    required this.wireChargePerMeter,
  });
}

/// Payment statistics for dashboard
class PaymentStatistics {
  final int totalPayments;
  final int approvedPayments;
  final int pendingPayments;
  final int rejectedPayments;
  final int overduePayments;
  final double approvalRate;
  final double totalRevenue;
  final double pendingAmount;
  final int currentYear;

  PaymentStatistics({
    required this.totalPayments,
    required this.approvedPayments,
    required this.pendingPayments,
    required this.rejectedPayments,
    required this.overduePayments,
    required this.approvalRate,
    required this.totalRevenue,
    required this.pendingAmount,
    required this.currentYear,
  });
}
